---
title:  正则表达式
tags: frontend
categories: 介绍
---

所有的语言的正则表达式还有一些更强大的功能，比如

1、子表达式的索引和回溯
2、回溯引用在replace中的应用
3、（肯定 | 否定）向前查找
4、（肯定 | 否定）向后查找 ===> JS不支持
5、条件查找 ===>JS不支持 Orz......

下面说的均是JS的正则

-----

一、子表达式的索引和回溯

JS中用括号括起来的大部分都可以成为一个子表达式（按照先后顺序从1到n），而整个正则则是第0个子表达式

例如：var reg = /(好).*?\1/g;  ===>  这里的“（好）”就是正个reg的  第一个  子表达式，后面的“\1”就代表着前面的第一个子表达式，因为是 1 嘛！

让我们来匹配点什么：var str ="你好吗？我很好！";

str.match(reg) ===> 返回结果：["好吗？我很好"]

这里看到了，从第一个“好”，匹配到第二个好，这也就是我理解的子表达式的索引和回溯（我是这么叫它的）。

补一句，reg里面的“*?”是懒惰匹配，就是尽量少的匹配，懒惰匹配的原理就是在修饰符的后面几个“？”，因为“？”是匹配0次或者1次嘛，so你懂得。

二、回溯引用在replace中的应用

直接从简单的例子入手：

正则表达式：var reg = /-(\w)/g;

匹配str：var str ="my-love";

输出：console.log(str.replace(reg,function($0,$1) {

console.log($0);

console.log($1);

}));

结果如下图：




控制台结果


个人分析图如下：

![](https://raw.githubusercontent.com/FoxDaxian/FoxDaxian.github.io/master/assets/picgo/20190722172802.png)


分析图


相信看了上面的分析，大家也能明白个七八，只要在replace中的函数中 return $1.toLowerCase()，是不是就完成了将带横线的字符转为驼峰字符的功能？大家试一下就会了解。

这里面的“$1”我理解为正则里面的“/1”，也就是说和“/1”的思路是差不多的，只不过应该用到replace中，不过好像也只能用到replace中，其他方面我还没接触到。

三、（肯定 | 否定）向前查找

先问大家一个问题，如果给大家一段话，里面有数字、中文和40$，要求匹配$前面的数字并且不能匹配后面没有$符号的数字，大家会如何匹配呢？（先想一想）

就上面的问题来举例子，从例子入手：

匹配的str：var str ="我出50$买灵能100%第二季";

正则表达式：var reg = /\d+(?=\$)/g;

输出：console.log(str.match(reg));

结果为：["50"]

这个结果就是我们想要的，而“(?=\$)”就是所谓的（肯定）正向查找。

我的理解是：“(?=\$)”的“?=”的“=”后面是要匹配的关键字，如果匹配到，就用“\d+”（也就是(?=\$)之前的）来匹配关键字之前的字符串或者其他。但是最后不会包含这个关键字哦。现在看起来是不是特别贴合这个名字“向前查找”。

那么（否定）向前查找呢？

还是那个例子只不过把正则表达式换一下

正则表达式：var reg = /\d+(?!\$)/g; ===> 注意 这里 将“?=”变为“?!”

返回结果：["5", "100"]

为什么是这个结果呢？因为是否定的，也就是取反，从“?!”中的“!”可以看出，匹配的是 数字 加 $ 之外的数字，那么为什么会返回5呢，这个我猜想是懒惰匹配的，所以会匹配“0$”，将前面的“5”抛弃了，并且返回了被匹配字符串的所以其他数字，就是这样喵。

四、（肯定 | 否定）向后查找 和 条件查找不支持，所以就没必要说了。有兴趣的可以自己去看看。

以上内容均属个人简洁，不对的地方望指出，最后祝大家在前端之路上越来越顺利。

没有了~~~